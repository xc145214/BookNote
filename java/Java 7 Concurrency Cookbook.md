# Java 7 并发指南

## 1. 线程管理

现代所有的操作系统都允许并发地执行任务。这种并发是**进程级别**的并发。
在同一进程内，也会同时有多种任务。这些在同一进程内运行的并发任务称之为**线程**。

**线程的创建**

在Java中，我们有2个方式创建线程：

+ 通过直接继承thread类，然后覆盖run()方法。
+ 构建一个实现Runnable接口的类, 然后创建一个thread类对象并传递Runnable对象作为构造参数

**获取线程和设置线程信息**

+ ID: 每个线程的独特标识。
+ Name: 线程的名称。
+ Priority: 线程对象的优先级。优先级别在1-10之间，1是最低级，10是最高级。不建议改变它们的优先级，但是你想的话也是可以的。
+ Status: 线程的状态。在Java中，线程只能有这6种中的一种状态： new, runnable, blocked, waiting, time waiting, 或 terminated.

**线程的终端**

一个多个线程在执行的Java程序，只有当其全部的线程执行结束时（更具体的说，是所有非守护线程结束或者某个线程调用System.exit()方法的时候），它才会结束运行。有时，你需要为了终止程序而结束一个线程，或者当程序的用户想要取消某个Thread对象正在做的任务。

Java提供中断机制来通知线程表明我们想要结束它。中断机制的特性是线程需要检查是否被中断，而且还可以决定是否响应结束的请求。所以，线程可以忽略中断请求并且继续运行。

但是如果线程实现的是由复杂的算法分成的一些方法，或者它的方法有递归调用，那么我们可以用更好的机制来控制线程中断。为了这个Java提供了InterruptedException异常。当你检测到程序的中断并在run()方法内捕获，你可以抛这个异常。

**线程的休眠与恢复**

有时, 你会感兴趣在一段确定的时间内中断执行线程。例如, 程序的一个线程每分钟检查反应器状态。其余时间，线程什么也不做。在这段时间，线程不使用任何计算机资源。过了这段时间，当JVM选择它时，线程会准备好继续执行。为达此目的，你可以使用Thread类的 sleep() 方法 。此方法接收一个整数作为参数，表示线程暂停运行的毫秒数。 在调用sleep() 方法后，当时间结束时，当JVM安排他们CPU时间，线程会继续按指令执行，

另一种可能是使用一个有TimeUnit列举元素的sleep() 方法，使用线程类的 sleep() 方法让当前线程睡眠，但是它接收的参数单位是表示并转换成毫秒的。

**等待线程的终结**

在某些情况下，我们需要等待线程的终结。例如，我们可能会遇到程序在执行前需要初始化资源。在执行剩下的代码之前，我们需要等待线程完成初始化任务。

为达此目的, 我们使用Thread 类的join() 方法。当前线程调用某个线程的这个方法时，它会暂停当前线程，直到被调用线程执行完成。

Java 提供2种形式的 join() 方法:

```
join (long milliseconds)
join (long milliseconds, long nanos)
```

第一种join() 方法, 这方法让调用线程等待特定的毫秒数。例如，如果thread1对象使用代码thread2.join(1000), 那么线程 thread1暂停运行，直到以下其中一个条件发生：

+ thread2 结束运行
+ 1000 毫秒过去了

当其中一个条件为真时，join() 方法返回。

第二个版本的 join() 方法和第一个很像，只不过它接收一个毫秒数和一个纳秒数作为参数。

**守护线程的创建和运行**

ava有一种特别的线程叫做守护线程。这种线程的优先级非常低，通常在程序里没有其他线程运行时才会执行它。当守护线程是程序里唯一在运行的线程时，JVM会结束守护线程并终止程序。

根据这些特点，守护线程通常用于在同一程序里给普通线程（也叫使用者线程）提供服务。它们通常无限循环的等待服务请求或执行线程任务。它们不能做重要的任务，因为我们不知道什么时候会被分配到CPU时间片，并且只要没有其他线程在运行，它们可能随时被终止。JAVA中最典型的这种类型代表就是垃圾回收器。

**在线程里处理不受控制的异常**

Java里有2种异常:

+ 检查异常（Checked exceptions）: 这些异常必须强制捕获它们或在一个方法里的throws子句中。 例如， IOException 或者ClassNotFoundException。
+ 未检查异常（Unchecked exceptions）: 这些异常不用强制捕获它们。例如， NumberFormatException。
在一个线程 对象的 run() 方法里抛出一个检查异常，我们必须捕获并处理他们。因为 run() 方法不接受 throws 子句。当一个非检查异常被抛出，默认的行为是在控制台写下stack trace并退出程序。

幸运的是, Java 提供我们一种机制可以捕获和处理线程对象抛出的未检测异常来避免程序终结。


**使用本地线程变量**

并发应用的一个关键地方就是共享数据。这个对那些扩展Thread类或者实现Runnable接口的对象特别重要。

如果你创建一个类对象，实现Runnable接口，然后多个Thread对象使用同样的Runnable对象，全部的线程都共享同样的属性。这意味着，如果你在一个线程里改变一个属性，全部的线程都会受到这个改变的影响。

有时，你希望程序里的各个线程的属性不会被共享。 Java 并发 API提供了一个很清楚的机制叫本地线程变量。

**线程组**

Java并发 API里有个有趣的方法是把线程分组。这个方法允许我们按线程组作为一个单位来处理。例如，你有一些线程做着同样的任务，你想控制他们，无论多少线程还在运行，他们的状态会被一个call 中断。

Java 提供 ThreadGroup 类来组织线程。 ThreadGroup 对象可以由 Thread 对象组成和由另外的 ThreadGroup 对象组成,生成线程树结构。


**处理线程组内不受控制异常**

对于编程语言来说，一个非常重要的事情是提供管理应用出错情况的机制。Java 语言, 作为最现代的编程语言，实现except基于异常的机制来管理出错情况，它提供很多种类来表示不同的错误。当检测到一个异常状况时，这些异常会被Java类们抛出。你也可以使用这些异常, 或者实现你自己的异常, 来管理你的类产生的错误。

Java 也提供机制来捕捉和处理这些异常 。有些一定要被捕捉或者使用方法的throws句组再抛出，这些异常称为检查异常（checked exceptions）。有些异常不需要被捕捉，这些称为未检查异常（unchecked exceptions)。

在这个指南中，你将学习了如何使用通用方法来处理线程对象抛出的所有未捕获的异常。

另一种可能是创建一个方法，捕获所有被ThreadGroup类的任何线程抛出的非捕捉异常。


**用线程工厂创建线程**

在面向对象编程的世界中，工厂模式是最有用的设计模式。它是一个创造模式，还有它的目的是创建一个或几个类的对象的对象。然后，当我们想创建这些类的对象时，我们使用工厂来代替new操作。

有了这个工厂，我们有这些优势来集中创建对象们：

+ 更简单的改变了类的对象创建或者说创建这些对象的方式。
+ 更简单的为了限制的资源限制了对象的创建。 例如， 我们只new一个此类型的对象。
+ 更简单的生成创建对象的统计数据。
Java提供一个接口， ThreadFactory 接口实现一个线程对象工厂。 并发 API 使用线程工厂来创建线程的一些基本优势。


## 2. 基本线程同步

在并发编程中发生的最常见的一种情况是超过一个执行线程使用共享资源。在并发应用程序中，多个线程读或写相同的数据或访问同一文件或数据库连接这是正常的。这些共享资源会引发错误或数据不一致的情况，我们必须通过一些机制来避免这些错误。

解决这些问题从临界区的概念开始。临界区是访问一个共享资源在同一时间不能被超过一个线程执行的代码块。

Java(和 几乎所有的编程语言)提供同步机制，帮助程序员实现临界区。当一个线程想要访问一个临界区,它使用其中的一个同步机制来找出是否有任何其他线程执行临界 区。如果没有，这个线程就进入临界区。否则，这个线程通过同步机制暂停直到另一个线程执行完临界区。当多个线程正在等待一个线程完成执行的一个临界 区，JVM选择其中一个线程执行，其余的线程会等待直到轮到它们。

本章展示了一些的指南，指导如何使用Java语言提供的两种基本的同步机制:

+ 关键字synchronized
+ Lock接口及其实现

**同步方法**

使用 synchronized关键字来控制并发访问方法。只有一个执行线程将会访问一个对象中被synchronized关键字声明的方法。如果另一个线程试图访问同一个对象中任何被synchronized关键字声明的方法，它将被暂停，直到第一个线程结束方法的执行。

换句话说，每个方法声明为synchronized关键字是一个临界区，Java只允许一个对象执行其中的一个临界区。

静态方法有不同的行为。只有一个执行线程访问被synchronized关键字声明的静态方法，但另一个线程可以访问该类的一个对象中的其他非静态的方法。 你必须非常小心这一点，因为两个线程可以访问两个不同的同步方法，如果其中一个是静态的而另一个不是。如果这两种方法改变相同的数据,你将会有数据不一致 的错误。


**在同步的类里安排独立属性**

当你使用synchronized关键字来保护代码块时，你必须通过一个对象的引用作为参数。通常，你将会使用this关键字来引用执行该方法的对象，但是你也可以使用其他对象引用。通常情况下，这些对象被创建只有这个目的。比如，你在一个类中有被多个线程共享的两个独立属性。你必须同步访问每个变量，如果有一个线程访问一个属性和另一个线程在同一时刻访问另一个属性，这是没有问题的。

**在同步代码中使用条件**

在并发编程中的一个经典问题是生产者与消费者问题，我们有一个数据缓冲区，一个或多个数据的生产者在缓冲区存储数据，而一个或多个数据的消费者，把数据从缓冲区取出。

由于缓冲区是一个共享的数据结构，我们必须采用同步机制，比如synchronized关键字来控制对它的访问。但是我们有更多的限制因素，如果缓冲区是满的，生产者不能存储数据，如果缓冲区是空的，消费者不能取出数据。

对于这些类型的情况，Java在Object对象中提供wait()，notify()，和notifyAll() 方法的实现。一个线程可以在synchronized代码块中调用wait()方法。如果在synchronized代码块外部调用wait()方法，JVM会抛出IllegalMonitorStateException异常。当线程调用wait()方法，JVM让这个线程睡眠，并且释放控制 synchronized代码块的对象，这样，虽然它正在执行但允许其他线程执行由该对象保护的其他synchronized代码块。为了唤醒线程，你必 须在由相同对象保护的synchronized代码块中调用notify()或notifyAll()方法。

**使用Lock同步代码块**

Java提供另外的机制用来同步代码块。它比synchronized关键字更加强大、灵活。它是基于Lock接口和实现它的类（如ReentrantLock）。这种机制有如下优势：

+ 它允许以一种更灵活的方式来构建synchronized块。使用synchronized关键字，你必须以结构化方式得到释放synchronized代码块的控制权。Lock接口允许你获得更复杂的结构来实现你的临界区。
+ Lock 接口比synchronized关键字提供更多额外的功能。新功能之一是实现的tryLock()方法。这种方法试图获取锁的控制权并且如果它不能获取该锁，是因为其他线程在使用这个锁，它将返回这个锁。使用synchronized关键字，当线程A试图执行synchronized代码块，如果线程B正在执行它，那么线程A将阻塞直到线程B执行完synchronized代码块。使用锁，你可以执行tryLock()方法，这个方法返回一个 Boolean值表示，是否有其他线程正在运行这个锁所保护的代码。
+ 当有多个读者和一个写者时，Lock接口允许读写操作分离。
+ Lock接口比synchronized关键字提供更好的性能。

**使用读/写锁同步数据访问**

锁所提供的最重要的改进之一就是ReadWriteLock接口和唯一 一个实现它的ReentrantReadWriteLock类。这个类提供两把锁，一把用于读操作和一把用于写操作。同时可以有多个线程执行读操作，但只有一个线程可以执行写操作。当一个线程正在执行一个写操作，不可能有任何线程执行读操作。


**修改Lock的公平性**

在ReentrantLock类和 ReentrantReadWriteLock类的构造器中，允许一个名为fair的boolean类型参数，它允许你来控制这些类的行为。默认值为 false，这将启用非公平模式。在这个模式中，当有多个线程正在等待一把锁（ReentrantLock或者 ReentrantReadWriteLock），这个锁必须选择它们中间的一个来获得进入临界区，选择任意一个是没有任何标准的。true值将开启公平 模式。在这个模式中，当有多个线程正在等待一把锁（ReentrantLock或者ReentrantReadWriteLock），这个锁必须选择它们 中间的一个来获得进入临界区，它将选择等待时间最长的线程。考虑到之前解释的行为只是使用lock()和unlock()方法。由于tryLock()方 法并不会使线程进入睡眠，即使Lock接口正在被使用，这个公平属性并不会影响它的功能。

**在Lock中使用多个条件**

一个锁可能伴随着多个条件。这些条件声明在Condition接口中。 这些条件的目的是允许线程拥有锁的控制并且检查条件是否为true，如果是false，那么线程将被阻塞，直到其他线程唤醒它们。Condition接口提供一种机制，阻塞一个线程和唤醒一个被阻塞的线程。

所有Condition对象都与锁有关，并且使用声明在Lock接口中的newCondition()方法来创建。使用condition做任何操作之前， 你必须获取与这个condition相关的锁的控制。所以，condition的操作一定是在以调用Lock对象的lock()方法为开头，以调用相同 Lock对象的unlock()方法为结尾的代码块中。

当一个线程在一个condition上调用await()方法时，它将自动释放锁的控制，所以其他线程可以获取这个锁的控制并开始执行相同操作，或者由同个锁保护的其他临界区。

> 注释：当一个线程在一个condition上调用signal()或signallAll()方法，一个或者全部在这个condition上等待的线程将被唤醒。这并不能保证的使它们现在睡眠的条件现在是true，所以你必须在while循环内部调用await()方法。你不能离开这个循环，直到 condition为true。当condition为false，你必须再次调用 await()方法。

你必须十分小心 ，在使用await()和signal()方法时。如果你在condition上调用await()方法而却没有在这个condition上调用signal()方法，这个线程将永远睡眠下去。

在调用await()方法后，一个线程可以被中断的，所以当它正在睡眠时，你必须处理InterruptedException异常。

Condition接口提供不同版本的await()方法，如下：

+ await(long time, TimeUnit unit):这个线程将会一直睡眠直到：

(1)它被中断

(2)其他线程在这个condition上调用singal()或signalAll()方法

(3)指定的时间已经过了

(4)TimeUnit类是一个枚举类型如下的常量：

`DAYS,HOURS, MICROSECONDS, MILLISECONDS, MINUTES, NANOSECONDS,SECONDS`

+ awaitUninterruptibly():这个线程将不会被中断，一直睡眠直到其他线程调用signal()或signalAll()方法
+ awaitUntil(Date date):这个线程将会一直睡眠直到：

(1)它被中断

(2)其他线程在这个condition上调用singal()或signalAll()方法

(3)指定的日期已经到了

你可以在一个读/写锁中的ReadLock和WriteLock上使用conditions。

## 3. 线程同步工具

在第二章基本的线程同步中，我们学习了同步和critical section的内容。基本上，当多个并发任务共享一个资源时就称为同步，例如：一个对象或者一个对象的属性。访问这个资源的代码块称为：临界区。

如果机制没有使用恰当，那么可能会导致错误的结果，或者数据不一致，又或者出现异常情况。所以必须采取java语言提供的某个恰当的同步机制来避免这些问题。

在第二章，基本的线程同步中，我们学会了以下2个同步机制：

+ 关键词同步
+ Lock接口和它的实现类们：ReentrantLock, ReentrantReadWriteLock.ReadLock, 和 ReentrantReadWriteLock.WriteLock

在此章节，我们将学习怎样使用高等级的机制来达到多线程的同步。这些高等级机制有：

+ Semaphores: 控制访问多个共享资源的计数器。此机制是并发编程的最基本的工具之一，而且大部分编程语言都会提供此机制。
+ CountDownLatch: CountDownLatch 类是Java语言提供的一个机制，它允许线程等待多个操作的完结。
+ CyclicBarrier: CyclicBarrier 类是又一个java语言提供的机制，它允许多个线程在同一个点同步。
+ Phaser: Phaser类是又一个java语言提供的机制，它控制并发任务分成段落来执行。全部的线程在继续执行下一个段之前必须等到之前的段执行结束。这是Java 7 API的一个新特性。
+ Exchanger: Exchanger类也是java语言提供的又一个机制，它提供2个线程间的数据交换点。

Semaphores是最基本的同步机制可以用来在任何问题中保护任何critical section。其他的机制只有在之前描述的那些有特殊特点的应用中使用。请根据你的应用的特点来选择适当的机制。

**控制并发访问资源**

Semaphore(信号量)是一个控制访问多个共享资源的计数器。

Semaphore的内容是由Edsger Dijkstra引入并在 THEOS操作系统上第一次使用。

当一个线程想要访问某个共享资源，首先，它必须获得semaphore。如果semaphore的内部计数器的值大于0，那么semaphore减少计数器的值并允许访问共享的资源。计数器的值大于0表示，有可以自由使用的资源，所以线程可以访问并使用它们。

另一种情况，如果semaphore的计数器的值等于0，那么semaphore让线程进入休眠状态一直到计数器大于0。计数器的值等于0表示全部的共享资源都正被线程们使用，所以此线程想要访问就必须等到某个资源成为自由的。

当线程使用完共享资源时，他必须放出semaphore为了让其他线程可以访问共享资源。这个操作会增加semaphore的内部计数器的值。

**控制并发访问多个资源**

在并发访问资源的控制中，你学习了信号量（semaphores）的基本知识。

在上个指南，你实现了使用binary semaphores的例子。那种semaphores是用来保护访问一个共享资源的，或者说一个代码片段每次只能被一个线程执行。但是semaphores也可以用来保护多个资源的副本，也就是说当你有一个代码片段每次可以被多个线程执行。

**等待多个并发事件完成**

Java并发API提供这样的类，它允许1个或者多个线程一直等待，直到一组操作执行完成。 这个类就是CountDownLatch类。它初始一个整数值，此值是线程将要等待的操作数。当某个线程为了想要执行这些操作而等待时， 它要使用 await()方法。此方法让线程进入休眠直到操作完成。 当某个操作结束，它使用countDown() 方法来减少CountDownLatch类的内部计数器。当计数器到达0时，这个类会唤醒全部使用await() 方法休眠的线程们。


CountDownLatch类有3个基本元素：

+ 初始值决定CountDownLatch类需要等待的事件的数量。
+ await() 方法, 被等待全部事件终结的线程调用。
+ countDown() 方法，事件在结束执行后调用。

当创建 CountDownLatch 对象时，对象使用构造函数的参数来初始化内部计数器。每次调用 countDown() 方法, CountDownLatch 对象内部计数器减一。当内部计数器达到0时， CountDownLatch 对象唤醒全部使用 await() 方法睡眠的线程们。

不可能重新初始化或者修改CountDownLatch对象的内部计数器的值。一旦计数器的值初始后，唯一可以修改它的方法就是之前用的 countDown() 方法。当计数器到达0时， 全部调用 await() 方法会立刻返回，接下来任何countDown() 方法的调用都将不会造成任何影响。

此方法与其他同步方法有这些不同：

+ CountDownLatch 机制不是用来保护共享资源或者临界区。它是用来同步一个或者多个执行多个任务的线程。它只能使用一次。像之前解说的，一旦CountDownLatch的计数器到达0，任何对它的方法的调用都是无效的。如果你想再次同步，你必须创建新的对象。


**在同一个点同步任务**

Java 并发 API 提供了可以允许2个或多个线程在在一个确定点的同步应用。它是 CyclicBarrier 类。此类与在此章节的等待多个并发事件完成指南中的 CountDownLatch 类相似，但是它有一些特殊性让它成为更强大的类。

CyclicBarrier 类有一个整数初始值，此值表示将在同一点同步的线程数量。当其中一个线程到达确定点，它会调用await() 方法来等待其他线程。当线程调用这个方法，CyclicBarrier阻塞线程进入休眠直到其他线程到达。当最后一个线程调用CyclicBarrier 类的await() 方法，它唤醒所有等待的线程并继续执行它们的任务。

CyclicBarrier 类有个有趣的优势是，你可以传递一个外加的 Runnable 对象作为初始参数，并且当全部线程都到达同一个点时，CyclicBarrier类 会把这个对象当做线程来执行。此特点让这个类在使用 divide 和 conquer 编程技术时，可以充分发挥任务的并行性，

CyclicBarrier 类有另一个版本的 await() 方法:

+ await(long time, TimeUnit unit): 线程会一直休眠直到被中断；内部计数器到达0，或者特定的时间过去了。TimeUnit类有多种常量： DAYS, HOURS, MICROSECONDS, MILLISECONDS, MINUTES, NANOSECONDS, and SECONDS.
此类也提供了 getNumberWaiting() 方法，返回被 await() 方法阻塞的线程数，还有 getParties() 方法，返回将与CyclicBarrier同步的任务数。

+ 重置 CyclicBarrier 对象

CyclicBarrier 类与CountDownLatch有一些共同点，但是也有一些不同。最主要的不同是，CyclicBarrier对象可以重置到它的初始状态，重新分配新的值给内部计数器，即使它已经被初始过了。

可以使用 CyclicBarrier的reset() 方法来进行重置操作。当这个方法被调用后，全部的正在await() 方法里等待的线程接收到一个 BrokenBarrierException 异常。此异常在例子中已经用打印stack trace处理了，但是在一个更复制的应用，它可以执行一些其他操作，例如重新开始执行或者在中断点恢复操作。

+ 破坏 CyclicBarrier 对象 

CyclicBarrier 对象可能处于一个特殊的状态，称为 broken。当多个线程正在 await() 方法中等待时，其中一个被中断了，此线程会收到 InterruptedException 异常，但是其他正在等待的线程将收到 BrokenBarrierException 异常，并且 CyclicBarrier 会被置于broken 状态中。

CyclicBarrier 类提供了isBroken() 方法，如果对象在 broken 状态，返回true，否则返回false。


**运行阶段性并发任务**

Java 并发 API 提供的一个非常复杂且强大的功能是，能够使用Phaser类运行阶段性的并发任务。当某些并发任务是分成多个步骤来执行时，那么此机制是非常有用的。Phaser类提供的机制是在每个步骤的结尾同步线程，所以除非全部线程完成第一个步骤，否则线程不能开始进行第二步。

相对于其他同步应用，我们必须初始化Phaser类与这次同步操作有关的任务数，我们可以通过增加或者减少来不断的改变这个数。


**控制并发阶段性任务的改变**

Phaser 类提供每次phaser改变阶段都会执行的方法。它是 onAdvance() 方法。它接收2个参数：当前阶段数和注册的参与者数；它返回 Boolean 值，如果phaser继续它的执行，则为 false；否则为真，即phaser结束运行并进入 termination 状态。

如果注册参与者为0，此方法的默认的实现值为真，要不然就是false。如果你扩展Phaser类并覆盖此方法，那么你可以修改它的行为。通常，当你要从一个phase到另一个，来执行一些行动时，你会对这么做感兴趣的。

**在并发任务间交换数据**

Java 并发 API 提供了一种允许2个并发任务间相互交换数据的同步应用。更具体的说，Exchanger 类允许在2个线程间定义同步点，当2个线程到达这个点，他们相互交换数据类型，使用第一个线程的数据类型变成第二个的，然后第二个线程的数据类型变成第一个的。

这个类在遇到类似生产者和消费者问题时，是非常有用的。来一个非常经典的并发问题：你有相同的数据buffer，一个或多个数据生产者，和一个或多个数据消费者。只是Exchange类只能同步2个线程，所以你只能在你的生产者和消费者问题中只有一个生产者和一个消费者时使用这个类。

## 4. 线程执行者

通常，当你在Java中开发一个简单的并发编程应用程序，你会创建一些Runnable对象并创建相应的Thread对象来运行它们。如果你开发一个运行多个并发任务的程序，这种途径的缺点如下：

+ 你必须要实现很多相关代码来管理Thread对象（创建，结束，获得的结果）。
+ 你必须给每个任务创建一个Thread对象。如果你执行一个大数据量的任务，那么这可能影响应用程序的吞吐量。
+ 你必须有效地控制和管理计算机资源。如果你创建太多线程，会使系统饱和。

为了解决以上问题，从Java5开始JDK并发API提供一种机制。这个机制被称为Executor framework，接口核心是Executor，Executor的子接口是ExecutorService，而ThreadPoolExecutor类则实现了这两个接口。
这个机制将任务的创建与执行分离。使用执行者，你只要实现Runnable对象并将它们提交给执行者。执行者负责执行，实例化和运行这些线程。除了这些，它还可以使用线程池提高了性能。当你提交一个任务给这个执行者，它试图使用线程池中的线程来执行任务，从而避免继续创建线程。

Callable接口是Executor framework的另一个重要优点。它跟Runnable接口很相似，但它提供了两种改进，如下：

+ 这个接口中主要的方法叫call()，可以返回结果。
+ 当你提交Callable对象到执行者，你可以获取一个实现Future接口的对象，你可以用这个对象来控制Callable对象的状态和结果。

**创建一个线程执行者**

使用Executor framework的第一步就是创建一个ThreadPoolExecutor类的对象。你可以使用这个类提供的4个构造器或Executors工厂类来 创建ThreadPoolExecutor。一旦有执行者，你就可以提交Runnable或Callable对象给执行者来执行。


**创建一个大小固定的线程执行者**

当你使用由Executors类的 newCachedThreadPool()方法创建的基本ThreadPoolExecutor，你会有执行者运行在某一时刻的线程数的问题。这个执行者为每个接收到的任务创建一个线程（如果池中没有空闲的线程），所以，如果你提交大量的任务，并且它们有很长的（执行）时间，你会使系统过载和引发应用程序性能不佳的问题。

如果你想要避免这个问题，Executors类提供一个方法来创建大小固定的线程执行者。这个执行者有最大线程数。 如果你提交超过这个最大线程数的任务，这个执行者将不会创建额外的线程，并且剩下的任务将会阻塞，直到执行者有空闲线程。这种行为，保证执行者不会引发应用程序性能不佳的问题。

**执行者执行返回结果的任务**

Executor framework的一个优点是你可以并发执行返回结果的任务。Java并发API使用以下两种接口来实现：

+ Callable：此接口有一个call()方法。在这个方法中，你必须实现任务的（处理）逻辑。Callable接口是一个参数化的接口。意味着你必须表明call()方法返回的数据类型。
+ Future：此接口有一些方法来保证Callable对象结果的获取和管理它的状态。

**运行多个任务并处理第一个结果**

在并发编程中的一个常见的问题就是，当有多种并发任务解决一个问题时，你只对这些任务的第一个结果感兴趣。比如，你想要排序一个数组。你有多种排序算法。 你可以全部启用它们，并且获取第一个结果（对于给定数组排序最快的算法的结果）。

**运行多个任务并处理所有结果**

执行者框架允许你在不用担心线程创建和执行的情况下，并发的执行任务。它还提供了Future类，这个类可以用来控制任务的状态,也可以用来获得执行者执行任务的结果。

如果你想要等待一个任务完成，你可以使用以下两种方法：

+ 如果任务执行完成，Future接口的isDone()方法将返回true。
+ ThreadPoolExecutor类的awaitTermination()方法使线程进入睡眠，直到每一个任务调用shutdown()方法之后完成执行。

这两种方法都有一些缺点。第一个方法，你只能控制一个任务的完成。第二个方法，你必须等待一个线程来关闭执行者，否则这个方法的调用立即返回。

ThreadPoolExecutor类提供一个方法，允许你提交任务列表给执行者，并且在这个列表上等待所有任务的完成。

**执行者延迟运行一个任务**

执行者框架提供ThreadPoolExecutor类，使用池中的线程来执行Callable和Runnable任务，这样可以避免所有线程的创建操作。当你提交一个任务给执行者，会根据执行者的配置尽快执行它。在有些使用情况下，当你对尽快执行任务不感觉兴趣。你可能想要在一段时间之后执行任务或周期性地执行任务。基于这些目的，执行者框架提供 ScheduledThreadPoolExecutor类。

**执行者周期性地运行一个任务**

执行者框架提供ThreadPoolExecutor类，使用池中的线程执行并发任务，从而避免所有线程的创建操作。当你提交任务给执行者，根据它的配置，它尽快地执行任务。当它结束，任务将被执行者删除，如果你想再次运行任务，你必须再次提交任务给执行者。

但是执行者框架通过ScheduledThreadPoolExecutor类可以执行周期性任务。

**执行者取消一个任务**

当你使用执行者工作时，你不得不管理线程。你只实现Runnable或 Callable任务和把它们提交给执行者。执行者负责创建线程，在线程池中管理它们，当它们不需要时，结束它们。有时候，你想要取消已经提交给执行者 的任务。在这种情况下，你可以使用Future的cancel()方法，它允许你做取消操作。在这个指南中，你将学习如何使用这个方法来取消已经提交给执行者的任务。

当你想要取消你已提交给执行者的任务，使用Future接口的cancel()方法。根据cancel()方法参数和任务的状态不同，这个方法的行为将不同：

+ 如果这个任务已经完成或之前的已被取消或由于其他原因不能被取消，那么这个方法将会返回false并且这个任务不会被取消。
+ 如果这个任务正在等待执行者获取执行它的线程，那么这个任务将被取消而且不会开始它的执行。如果这个任务已经正在运行，则视方法的参数情况而定。 cancel()方法接收一个Boolean值参数。
+ 如果参数为true并且任务正在运行，那么这个任务将被取消。如果参数为false并且任务正在运行，那么这个任务将不会被取消。

**执行者控制一个任务完成**

FutureTask类提供一个done()方法，允许你在执行者执行任务完成后执行一些代码。你可以用来做一些后处理操作，生成一个报告，通过e-mail发送结果，或释放一些资源。当执行的任务由FutureTask来控制完成，FutureTask会内部调用这个方法。这个方法在任务的结果设置和它的状态变成isDone状态之后被调用，不管任务是否已经被取消或正常完成。

默认情况下，这个方法是空的。你可以重写FutureTask类实现这个方法来改变这种行为。