# Java 7 并发指南

## 1. 线程管理

现代所有的操作系统都允许并发地执行任务。这种并发是**进程级别**的并发。
在同一进程内，也会同时有多种任务。这些在同一进程内运行的并发任务称之为**线程**。

**线程的创建**

在Java中，我们有2个方式创建线程：

+ 通过直接继承thread类，然后覆盖run()方法。
+ 构建一个实现Runnable接口的类, 然后创建一个thread类对象并传递Runnable对象作为构造参数

**获取线程和设置线程信息**

+ ID: 每个线程的独特标识。
+ Name: 线程的名称。
+ Priority: 线程对象的优先级。优先级别在1-10之间，1是最低级，10是最高级。不建议改变它们的优先级，但是你想的话也是可以的。
+ Status: 线程的状态。在Java中，线程只能有这6种中的一种状态： new, runnable, blocked, waiting, time waiting, 或 terminated.

**线程的终端**

一个多个线程在执行的Java程序，只有当其全部的线程执行结束时（更具体的说，是所有非守护线程结束或者某个线程调用System.exit()方法的时候），它才会结束运行。有时，你需要为了终止程序而结束一个线程，或者当程序的用户想要取消某个Thread对象正在做的任务。

Java提供中断机制来通知线程表明我们想要结束它。中断机制的特性是线程需要检查是否被中断，而且还可以决定是否响应结束的请求。所以，线程可以忽略中断请求并且继续运行。

但是如果线程实现的是由复杂的算法分成的一些方法，或者它的方法有递归调用，那么我们可以用更好的机制来控制线程中断。为了这个Java提供了InterruptedException异常。当你检测到程序的中断并在run()方法内捕获，你可以抛这个异常。

**线程的休眠与恢复**

有时, 你会感兴趣在一段确定的时间内中断执行线程。例如, 程序的一个线程每分钟检查反应器状态。其余时间，线程什么也不做。在这段时间，线程不使用任何计算机资源。过了这段时间，当JVM选择它时，线程会准备好继续执行。为达此目的，你可以使用Thread类的 sleep() 方法 。此方法接收一个整数作为参数，表示线程暂停运行的毫秒数。 在调用sleep() 方法后，当时间结束时，当JVM安排他们CPU时间，线程会继续按指令执行，

另一种可能是使用一个有TimeUnit列举元素的sleep() 方法，使用线程类的 sleep() 方法让当前线程睡眠，但是它接收的参数单位是表示并转换成毫秒的。

**等待线程的终结**

在某些情况下，我们需要等待线程的终结。例如，我们可能会遇到程序在执行前需要初始化资源。在执行剩下的代码之前，我们需要等待线程完成初始化任务。

为达此目的, 我们使用Thread 类的join() 方法。当前线程调用某个线程的这个方法时，它会暂停当前线程，直到被调用线程执行完成。

Java 提供2种形式的 join() 方法:

```
join (long milliseconds)
join (long milliseconds, long nanos)
```

第一种join() 方法, 这方法让调用线程等待特定的毫秒数。例如，如果thread1对象使用代码thread2.join(1000), 那么线程 thread1暂停运行，直到以下其中一个条件发生：

+ thread2 结束运行
+ 1000 毫秒过去了

当其中一个条件为真时，join() 方法返回。

第二个版本的 join() 方法和第一个很像，只不过它接收一个毫秒数和一个纳秒数作为参数。

**守护线程的创建和运行**

ava有一种特别的线程叫做守护线程。这种线程的优先级非常低，通常在程序里没有其他线程运行时才会执行它。当守护线程是程序里唯一在运行的线程时，JVM会结束守护线程并终止程序。

根据这些特点，守护线程通常用于在同一程序里给普通线程（也叫使用者线程）提供服务。它们通常无限循环的等待服务请求或执行线程任务。它们不能做重要的任务，因为我们不知道什么时候会被分配到CPU时间片，并且只要没有其他线程在运行，它们可能随时被终止。JAVA中最典型的这种类型代表就是垃圾回收器。

**在线程里处理不受控制的异常**

Java里有2种异常:

+ 检查异常（Checked exceptions）: 这些异常必须强制捕获它们或在一个方法里的throws子句中。 例如， IOException 或者ClassNotFoundException。
+ 未检查异常（Unchecked exceptions）: 这些异常不用强制捕获它们。例如， NumberFormatException。
在一个线程 对象的 run() 方法里抛出一个检查异常，我们必须捕获并处理他们。因为 run() 方法不接受 throws 子句。当一个非检查异常被抛出，默认的行为是在控制台写下stack trace并退出程序。

幸运的是, Java 提供我们一种机制可以捕获和处理线程对象抛出的未检测异常来避免程序终结。


**使用本地线程变量**

并发应用的一个关键地方就是共享数据。这个对那些扩展Thread类或者实现Runnable接口的对象特别重要。

如果你创建一个类对象，实现Runnable接口，然后多个Thread对象使用同样的Runnable对象，全部的线程都共享同样的属性。这意味着，如果你在一个线程里改变一个属性，全部的线程都会受到这个改变的影响。

有时，你希望程序里的各个线程的属性不会被共享。 Java 并发 API提供了一个很清楚的机制叫本地线程变量。

**线程组**

Java并发 API里有个有趣的方法是把线程分组。这个方法允许我们按线程组作为一个单位来处理。例如，你有一些线程做着同样的任务，你想控制他们，无论多少线程还在运行，他们的状态会被一个call 中断。

Java 提供 ThreadGroup 类来组织线程。 ThreadGroup 对象可以由 Thread 对象组成和由另外的 ThreadGroup 对象组成,生成线程树结构。


**处理线程组内不受控制异常**

对于编程语言来说，一个非常重要的事情是提供管理应用出错情况的机制。Java 语言, 作为最现代的编程语言，实现except基于异常的机制来管理出错情况，它提供很多种类来表示不同的错误。当检测到一个异常状况时，这些异常会被Java类们抛出。你也可以使用这些异常, 或者实现你自己的异常, 来管理你的类产生的错误。

Java 也提供机制来捕捉和处理这些异常 。有些一定要被捕捉或者使用方法的throws句组再抛出，这些异常称为检查异常（checked exceptions）。有些异常不需要被捕捉，这些称为未检查异常（unchecked exceptions)。

在这个指南中，你将学习了如何使用通用方法来处理线程对象抛出的所有未捕获的异常。

另一种可能是创建一个方法，捕获所有被ThreadGroup类的任何线程抛出的非捕捉异常。


**用线程工厂创建线程**

在面向对象编程的世界中，工厂模式是最有用的设计模式。它是一个创造模式，还有它的目的是创建一个或几个类的对象的对象。然后，当我们想创建这些类的对象时，我们使用工厂来代替new操作。

有了这个工厂，我们有这些优势来集中创建对象们：

+ 更简单的改变了类的对象创建或者说创建这些对象的方式。
+ 更简单的为了限制的资源限制了对象的创建。 例如， 我们只new一个此类型的对象。
+ 更简单的生成创建对象的统计数据。
Java提供一个接口， ThreadFactory 接口实现一个线程对象工厂。 并发 API 使用线程工厂来创建线程的一些基本优势。


## 基本线程同步

在并发编程中发生的最常见的一种情况是超过一个执行线程使用共享资源。在并发应用程序中，多个线程读或写相同的数据或访问同一文件或数据库连接这是正常的。这些共享资源会引发错误或数据不一致的情况，我们必须通过一些机制来避免这些错误。

解决这些问题从临界区的概念开始。临界区是访问一个共享资源在同一时间不能被超过一个线程执行的代码块。

Java(和 几乎所有的编程语言)提供同步机制，帮助程序员实现临界区。当一个线程想要访问一个临界区,它使用其中的一个同步机制来找出是否有任何其他线程执行临界 区。如果没有，这个线程就进入临界区。否则，这个线程通过同步机制暂停直到另一个线程执行完临界区。当多个线程正在等待一个线程完成执行的一个临界 区，JVM选择其中一个线程执行，其余的线程会等待直到轮到它们。

本章展示了一些的指南，指导如何使用Java语言提供的两种基本的同步机制:

+ 关键字synchronized
+ Lock接口及其实现

**同步方法**

使用 synchronized关键字来控制并发访问方法。只有一个执行线程将会访问一个对象中被synchronized关键字声明的方法。如果另一个线程试图访问同一个对象中任何被synchronized关键字声明的方法，它将被暂停，直到第一个线程结束方法的执行。

换句话说，每个方法声明为synchronized关键字是一个临界区，Java只允许一个对象执行其中的一个临界区。

静态方法有不同的行为。只有一个执行线程访问被synchronized关键字声明的静态方法，但另一个线程可以访问该类的一个对象中的其他非静态的方法。 你必须非常小心这一点，因为两个线程可以访问两个不同的同步方法，如果其中一个是静态的而另一个不是。如果这两种方法改变相同的数据,你将会有数据不一致 的错误。