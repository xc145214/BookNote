# 进制及计算机表示

[TOC]

## 1. 进制

我们平常使用的自然数是十进制的，在计算机中使用的是二进制运算，使用二进制是因为电子元器件只能用高低电压两种状态来进行组合和计算，这就决定了二进制是现代计算机的基础。为了方便表示，人们还经常会使用八进制和十六进制来记录二进制数。关于数的进位制，例如N位制，常见的一种观点是，低位满N，就向高位进一。除了这种理解之外，我们这里再讨论一种更有用的理解。那就是将数字的每一位赋予一个权重，一个数字的真实值就是每一位上的数字乘以这一位所对应的权重，然后再加起来。例如，对于一个十进制数，个数的权重是1 = 10^0，十位的权重是10^1，百位的权重是10^2，依次类推，那么，一个十进制数1368就可以表示为

```
(1368)_10 = 1* 10^3 + 3 * 10^2 + 6 * 10^1 + 8 * 10^0
```

同样，一个二进制数![(1101)_2](http://www.zhihu.com/equation?tex=%281101%29_2)也可以表达成

```
(1101)_2 = 1 * 2 ^3 + 1 * 2 ^2 + 0 * 2^1 + 1 * 2^0
```

这个分解式看起来很简单，但意义却很重大，这使得我们从“满几进一”的思维中跳出来，可以重新定义每个位的权重。比如在普通的十进制数中，十位的权重是10，百位的权重是100，但是，我们可以根据需要，**规定十位是十进制，百位是八进制的，也就是说，十位的权重仍然是10，百位的权重变成了8∗10 = 80**。

## 2. 计算机中数字的表示

Java中的byte类型是一个字节，8位，short是两个字节，16位，int是四个字节，32位，long是8字节，64位。为了方便描述，我们以byte为例，一个字节，8位能表达的范围是从(00000000)2 ~ (11111111)2，转成十进制，就是从0到255。但书上告诉我们，byte能表达的范围是-128~127。这就牵扯到了负数的表达了。在计算机里，对于有符号的数据类型，会把最高位做为符号位，如果为1，则为负数。

```java
int i = 1;
Assert.assertTrue((a << 30) > 0);
Assert.assertTrue((a << 31) < 0);
Assert.assertEquals((a << 31), Integer.MIN_VALUE);
```

以byte的情况进行分析。负数通常有三种表示方法。第一种，把符号位设为1，后面的数字等于这个负数的绝对值，例如-15就变成了10001111。这种方法称为原码。还有一种，保持符号位不变，后面的数字全部取反，例如-15就变成了11110000,这种方法称为反码。最后一种，称为补码，它是由反码加1得到的。例如，-1的反码是11111110，再加1就是11111111。使用补码的好处包括，0和-0的表示是相同的，正负数可以直接进行加减法运算，不必再做额外的转换。而原码和反码则不具备这样的优点。**所以现代计算机都是使用补码来表示负数**。

## 3. 递增进位制数

递增进位制数是这样一种数，它的最右一位(称为个位已经不太准确了，我们使用左右来代替个位十位的称呼)是二进制的，它的右数第二位是三进制的，右数第三位是四进制的 ……它的右数第N是N + 1进制的。用权重的观点来看，它的最右一位的权重是1，右数第二位的权重是1∗2 = 2!，右数第三位的权重是1∗2∗3 = 3!，右数第N的权重是N!。 我们也用上面的方法来表示递增进位制数：

```
(4321)_ = 4*4! + 3* 3! + 3*2! + 1*1! = 1*5! - 1 = 119
```

